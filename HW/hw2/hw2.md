# ðŸ“Œ Man Page Sections

| Section | Description |
|---------|-------------|
| **1** | **User commands** (executables & shell commands, e.g., `ls`, `cp`, `mv`) |
| **2** | **System calls** (functions provided by the kernel, e.g., `open`, `read`, `write`) |
| **3** | **Library functions** (C standard library, e.g., `printf`, `malloc`) |
| **4** | **Special files** (devices in `/dev`, e.g., `tty`, `null`) |
| **5** | **File formats & config files** (e.g., `/etc/passwd`, `fstab`) |
| **6** | **Games and screensavers** (e.g., `fortune`, `bs`) |
| **7** | **Miscellaneous** (macro packages, conventions, e.g., `man 7 inode`, `man 7 signal`) |
| **8** | **System administration commands** (root-only commands, e.g., `mount`, `iptables`) |
| **9** | **Kernel routines** (internal kernel functions, mostly for developers) |
# emojis
ðŸ˜€ Happy & Excited Faces
ðŸ˜ƒðŸ˜ðŸ˜†ðŸ˜„ðŸ˜…ðŸ˜‚ðŸ¤£ðŸ˜ŠðŸ˜‡ðŸ™‚ðŸ™ƒðŸ˜ºðŸ˜¸ðŸ˜¹ðŸ¤—ðŸ¥³ðŸ¥°ðŸ˜»ðŸ’–

ðŸ˜Ž Cool & Confident Faces
ðŸ˜ŽðŸ•¶ï¸ðŸ¤ ðŸ˜ðŸ˜ŒðŸ¤¤ðŸ˜¼ðŸ‘‘ðŸ’ªðŸ”¥ðŸŽ¸ðŸ¤˜ðŸ˜ˆðŸ˜‡ðŸ¦¸â€â™‚ï¸ðŸ¦¸â€â™€ï¸âœ¨

ðŸ¤© Amazed & Star-Struck Faces
ðŸ¤©ðŸ˜²ðŸ˜¯ðŸ˜®ðŸ˜µðŸ¤¯ðŸ¤—ðŸ¤¤ðŸ˜ðŸ˜»ðŸ’“ðŸ’žðŸ’«ðŸ’¥âš¡ðŸŽ†ðŸŽ‡ðŸŒŸ

ðŸ§ Curious & Playful Faces
ðŸ§ðŸ¤“ðŸ¤”ðŸ¤­ðŸ™„ðŸ˜œðŸ˜ðŸ˜›ðŸ¤ªðŸ˜¶â€ðŸŒ«ï¸ðŸ‘€ðŸ•µï¸â€â™‚ï¸ðŸ”ŽðŸŽ­ðŸ’­ðŸ’¡ðŸ”®

ðŸ”¥ High-Energy & Exciting Emojis  
ðŸš€ðŸ’¥âš¡âœ¨ðŸŽ‰ðŸŽŠðŸ’«ðŸŒŸðŸšðŸš‚ðŸŽï¸ðŸ’¨ðŸ”‹ðŸš€ðŸš´ðŸ’¨ðŸƒðŸ’¨ðŸŽ¯ðŸ†ðŸ¥‡ðŸŽ–ï¸ðŸ…ðŸ¥³ðŸ˜ƒðŸ˜ðŸ˜†ðŸ˜ŽðŸ¤©

ðŸ’¡ Innovation & Technology Emojis  
ðŸ§ ðŸ’¡ðŸ”¬ðŸ“¡ðŸ›°ï¸ðŸ¤–ðŸ”§âš™ï¸ðŸ’¾ðŸ’»ðŸ–¥ï¸âŒ¨ï¸ðŸ–±ï¸ðŸ“±ðŸ“¡ðŸŽ›ï¸ðŸ”ŠðŸ“¶ðŸ”‹ðŸ”ŒðŸ”ðŸ’¿ðŸ“€ðŸŽ¥ðŸŽ¬ðŸ“¸ðŸŽ¤ðŸŽ§ðŸŽµðŸŽ¶

ðŸ“ˆ Growth & Progress Emojis  
ðŸ“ˆðŸ“ŠðŸ“‰ðŸ’°ðŸ’ŽðŸ”ðŸ”¼â¬†ï¸ðŸ—ï¸ðŸ¢ðŸ›ï¸ðŸ°â›©ï¸ðŸ—¼ðŸ—½ðŸ™ï¸ðŸŒ†ðŸŒ‡ðŸŒ„ðŸŒ…â«â­ï¸â©â³âŒ›ðŸ•°ï¸â°ðŸ”„

ðŸŒ Space & Futuristic Emojis  
ðŸŒðŸŒŽðŸŒðŸªâ˜„ï¸ðŸŒ ðŸŒŒðŸ”­ðŸ‘¨â€ðŸš€ðŸ‘©â€ðŸš€ðŸ›¸ðŸ‘¾ðŸ¦¾ðŸ¦¿âš›ï¸â˜¢ï¸â˜£ï¸ðŸŒ€â™¾ï¸ðŸ›¤ï¸ðŸš¦ðŸ›°ï¸ðŸ›‘ðŸš§

ðŸ”® Mystical & Fantasy Emojis  
ðŸ§™â€â™‚ï¸ðŸ§™â€â™€ï¸ðŸ§â€â™‚ï¸ðŸ§â€â™€ï¸ðŸ§›â€â™‚ï¸ðŸ§›â€â™€ï¸ðŸ§œâ€â™‚ï¸ðŸ§œâ€â™€ï¸ðŸ¦„ðŸ‰ðŸ²ðŸ¦…ðŸ”¥ðŸŽ­ðŸŽªðŸ’­ðŸ¤¯ðŸ’¥ðŸŒ€ðŸŒˆðŸŒŠðŸ’ŽðŸ”®

ðŸ› ï¸ Hard Work & Hustle Emojis  
ðŸ’ªðŸ‹ï¸â€â™‚ï¸ðŸ‹ï¸â€â™€ï¸â›ï¸ðŸ”¨ðŸ› ï¸âš’ï¸ðŸªšðŸ”©ðŸ”—ðŸ›’ðŸš§ðŸ—ï¸ðŸ”ŽðŸ’¼ðŸ“–ðŸ—‚ï¸ðŸ“‚ðŸ“âœï¸âœï¸ðŸ“œðŸ“ƒðŸ“„

ðŸ”— Connectivity & Networking Emojis  
ðŸ“¡ðŸ“¡ðŸ”—ðŸ”„ðŸ”€ðŸ”ðŸ”‚ðŸ”ƒðŸ“žðŸ“²ðŸ“¶ðŸ“ ðŸ“¥ðŸ“¤ðŸ“¬ðŸ“­ðŸ’¬ðŸ—¨ï¸ðŸ’­ðŸ—£ï¸ðŸ“¢ðŸ“£ðŸ’Œâœ‰ï¸ðŸ“§ðŸ“ªðŸ“«

ðŸŽµ Music & Vibes Emojis  
ðŸŽµðŸŽ¶ðŸŽ¼ðŸŽ¤ðŸŽ§ðŸŽ·ðŸŽºðŸŽ¸ðŸ¥ðŸŽ¹ðŸŽ»ðŸ“»ðŸ“ºðŸŽ¥ðŸ“½ï¸ðŸŽ¬ðŸŽžï¸ðŸª„âœ¨ðŸŽ‡ðŸŽ†ðŸŽ‘ðŸ•ºðŸ’ƒ
# CSE 333 25wi Homework 2 ðŸ˜ŠðŸš€
## Goals

In this assignment you will use the LinkedList and HashTable modules that you built in Homework 1 in order to finish our implementation of a `file system crawler`, `indexer`, and `search engine`:

1. In Part A, you will build a module that reads the content of a file into memory, parses it into a series of words, and builds a linked list of (word, list of positions) information. æ‚¨å°†æž„å»ºä¸€ä¸ªæ¨¡å—ï¼Œè¯¥æ¨¡å—å°†æ–‡ä»¶å†…å®¹è¯»å–åˆ°å†…å­˜ä¸­ï¼Œå°†å…¶è§£æžä¸ºä¸€ç³»åˆ—å•è¯ï¼Œå¹¶æž„å»ºï¼ˆå•è¯ã€ä½ç½®åˆ—è¡¨ï¼‰ä¿¡æ¯çš„é“¾è¡¨ã€‚

2. In Part B, you will build modules that convert a series of these linked lists into an in-memory, inverted index. æ‚¨å°†æž„å»ºæ¨¡å—ï¼Œå°†ä¸€ç³»åˆ—è¿™äº›é“¾è¡¨è½¬æ¢ä¸ºå†…å­˜ä¸­çš„å€’æŽ’ç´¢å¼•ã€‚

3. In Part C, you will use this in-memory, inverted index to build a query processor that has a console-based interface. æ‚¨å°†ä½¿ç”¨å†…å­˜ä¸­çš„å€’æŽ’ç´¢å¼•æ¥æž„å»ºä¸€ä¸ªå…·æœ‰åŸºäºŽæŽ§åˆ¶å°çš„æŽ¥å£çš„æŸ¥è¯¢å¤„ç†å™¨ã€‚

å¦‚å‰æ‰€è¿°ï¼Œè¯·åœ¨å¼€å§‹ä½œä¸šå‰é€šè¯»æ•´ä¸ªæ–‡æ¡£ï¼Œå¹¶è¯·å°½æ—©å¼€å§‹ï¼è¦å®Œæˆè¿™é¡¹ä»»åŠ¡ï¼Œä½ éœ€è¦åšå¤§é‡çš„ç¼–ç ï¼Œè¿™è‚¯å®šä¼šæš´éœ²å‡ºä½ åœ¨Cã€æŒ‡é’ˆã€malloc/freeä»¥åŠLinkedListå’ŒHashTableå®žçŽ°çš„è¯­ä¹‰ç­‰å…ˆå‰ææ–™ä¸­å­˜åœ¨çš„ä»»ä½•æ¦‚å¿µç¼ºé™·ã€‚

## In-Memory File System Search Engine
### Part A: File Parser
æ‚¨å°†ç¼–å†™ä¸€ä¸ªæ¨¡å—ï¼Œå°†æ–‡æœ¬æ–‡ä»¶çš„å†…å®¹è¯»å–åˆ°å†…å­˜ä¸­ï¼Œç„¶åŽè§£æžæ–‡æœ¬æ–‡ä»¶ä»¥æŸ¥æ‰¾å…¶ä¸­çš„å•è¯ã€‚å½“å®ƒæ‰¾åˆ°å•è¯æ—¶ï¼Œå®ƒå°†æž„å»ºä¸€ä¸ªåŒ…å«æ¯ä¸ªå•è¯ä¸€æ¡è®°å½•çš„HashTableã€‚æ¯æ¡è®°å½•å°†åŒ…å«å•è¯çš„å°å†™å‰¯æœ¬ï¼Œä»¥åŠä¸€ä¸ªæŽ’åºçš„é“¾è¡¨ã€‚é“¾è¡¨çš„æ¯æ¡è®°å½•åœ¨å•è¯å‡ºçŽ°çš„æ–‡ä»¶ä¸­éƒ½åŒ…å«ä¸€ä¸ªåç§»é‡ï¼ˆæ–‡ä»¶ä¸­çš„ç¬¬ä¸€ä¸ªå­—ç¬¦åç§»é‡ä¸ºé›¶ï¼‰ã€‚

æˆ‘ä»¬çš„å•è¯è§£æžå™¨ä¸ä¼šå¾ˆèªæ˜Žã€‚å®ƒå°†æŠŠä»»ä½•ç”±éžå­—æ¯å­—ç¬¦åˆ†éš”çš„éžé›¶å­—æ¯å­—ç¬¦åºåˆ—è§†ä¸ºå•è¯ã€‚
![ç¤ºä¾‹å›¾ç‰‡](./1.png)
Specifically, note a few things:

- Each key in the hash table is the result of calling the hashtable module's FNVHash64() function, passing the string as the first argument, and the strlen(string) as the second argument. å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªé”®éƒ½æ˜¯è°ƒç”¨å“ˆå¸Œè¡¨æ¨¡å—çš„FNVHash64ï¼ˆï¼‰å‡½æ•°çš„ç»“æžœï¼Œå°†å­—ç¬¦ä¸²ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ï¼Œå°†strlenï¼ˆstringï¼‰ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ é€’ã€‚

- Each element in the hash table is a pointer to a heap-allocated structure that contains two fields; a string and a linked list. Note the string is lower-cased, and that our parser is not very smart: because it treats any sequence of alphabetic characters surrounded by non-alphabetic characters as words, the word I'll will be misparsed as the two words i and ll. å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯æŒ‡å‘åŒ…å«ä¸¤ä¸ªå­—æ®µçš„å †åˆ†é…ç»“æž„çš„æŒ‡é’ˆï¼›ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ä¸ªé“¾è¡¨ã€‚è¯·æ³¨æ„ï¼Œå­—ç¬¦ä¸²æ˜¯å°å†™çš„ï¼Œæˆ‘ä»¬çš„è§£æžå™¨ä¸æ˜¯å¾ˆèªæ˜Žï¼šå› ä¸ºå®ƒå°†ä»»ä½•è¢«éžå­—æ¯å­—ç¬¦åŒ…å›´çš„å­—æ¯å­—ç¬¦åºåˆ—è§†ä¸ºå•è¯ï¼Œæ‰€ä»¥å•è¯Iå°†è¢«é”™è¯¯åœ°è§£æžä¸ºä¸¤ä¸ªå•è¯Iå’Œllã€‚

- Each element in the linked list is an integer representing the position in the text file at which the word starts; this is both its byte offset and, since we are only handling ASCII files, the number of characters from the start of the file (each ASCII character is exactly 1 byte). So, the word "my" starts at offset 0 in the text file, the word "i" appears twice, once at offset 14 and once at offset 40, and the word "course" appears twice, once at offset 25 and once at offset 62. é“¾è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå•è¯åœ¨æ–‡æœ¬æ–‡ä»¶ä¸­çš„èµ·å§‹ä½ç½®ï¼›è¿™æ—¢æ˜¯å®ƒçš„å­—èŠ‚åç§»é‡ï¼Œä¹Ÿæ˜¯å› ä¸ºæˆ‘ä»¬åªå¤„ç†ASCIIæ–‡ä»¶ï¼Œä»Žæ–‡ä»¶å¼€å¤´å¼€å§‹çš„å­—ç¬¦æ•°ï¼ˆæ¯ä¸ªASCIIå­—ç¬¦æ°å¥½æ˜¯1ä¸ªå­—èŠ‚ï¼‰ã€‚å› æ­¤ï¼Œå•è¯â€œmyâ€åœ¨æ–‡æœ¬æ–‡ä»¶ä¸­çš„åç§»é‡0å¤„å¼€å§‹ï¼Œå•è¯â€œiâ€å‡ºçŽ°ä¸¤æ¬¡ï¼Œä¸€æ¬¡åœ¨åç§»é‡14å¤„ï¼Œä¸€æ¬¡æ˜¯åœ¨åç§»é‡40å¤„ï¼Œå•è¯â€œcourseâ€å‡ºçŽ°ä¸¤æ¬¡äºŽåç§»é‡25å¤„å’Œåç§»é‡62å¤„ã€‚

- Each list is sorted in ascending order. æ¯ä¸ªåˆ—è¡¨éƒ½æŒ‰å‡åºæŽ’åˆ—ã€‚

```
// jusut to check what should the correct answer looks like

$ valgrind --leak-check=full ./solution_binaries/test_suite

// ask man for help to check stat
$ man 2 stat

// ask man for help to check inode
$ man 7 inode

// search or find some words in man page or vim page
// / (forward search) or ? (backward search)
//  S_ISREG(m)  is it a regular file?
$ /S_ISREG

// ask man for help to check open
$ man 2 open
```
`FileParser.h`:  

`char* ReadFileToString(const char *file_name, int *size);`
å¦‚æžœæ–‡ä»¶åŒ…å«nullï¼ˆå³é›¶å€¼ï¼‰ï¼Œåˆ™ä¸æä¾›ç‰¹æ®Šçš„è½¬ä¹‰/å¤„ç†

Arguments:  
file_nameï¼šåŒ…å«è¦è¯»å–çš„æ–‡ä»¶çš„è·¯å¾„åçš„å­—ç¬¦ä¸²  
sizeï¼šå¦‚æžœæˆåŠŸï¼Œåˆ™ä»¥å­—èŠ‚ä¸ºå•ä½è¿”å›žå¤§å°çš„è¾“å‡ºå‚æ•°  

Returns:  
NULL: å¦‚æžœè¯»å–å¤±è´¥  
This function will add '\0' to the end of the file; 'size' doesn't include the final '\0'.  

``` c
char* ReadFileToString(const char *file_name, int *size);

typedef struct WordPositions {
  char        *word;        // normalized word.  Owned.
  LinkedList  *positions;   // list of DocPositionOffset_t.  Owned.
} WordPositions;

HashTable* ParseIntoWordPositionsTable(char *file_contents);

void FreeWordPositionsTable(HashTable *table);
///////////////////////////////////////////////////////////////////////////////

#define ASCII_UPPER_BOUND 0x7F

// Since our hash table dynamically grows, we'll start with a small
// number of buckets.
#define HASHTABLE_INITIAL_NUM_BUCKETS 2

// Frees a WordPositions.positions's payload, which is just a
// DocPositionOffset_t.
static void NoOpFree(LLPayload_t payload) { }

// Frees a WordPositions struct.
static void FreeWordPositions(HTValue_t payload) {
  WordPositions *pos = (WordPositions*) payload;
  LinkedList_Free(pos->positions, &NoOpFree);
  free(pos->word);
  free(pos);
}

// Add a normalized word and its byte offset into the WordPositions HashTable.
static void AddWordPosition(HashTable *tab, char *word,
                            DocPositionOffset_t pos);

// Parse the passed-in string into normalized words and insert into a HashTable
// of WordPositions structures.
static void InsertContent(HashTable *tab, char *content);

```

